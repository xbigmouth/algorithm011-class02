 

## 位运算

 **1. 190 颠倒的二进制位**
**2. 191 位1的个数**
**3. 231 2的幂**
**4. 371 两整数之和**
**5. 405 数字转化为十六进制**

## 190 颠倒的二进制位

### 题目大意

颠倒给定的 32 位无符号整数的二进制位。
**示例1**：

> 输入: 00000010100101000001111010011100
> 输出: 00111001011110000010100101000000
> 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
> 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

**示例2**：

> 输入：11111111111111111111111111111101
> 输出：10111111111111111111111111111111
> 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
> 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。

### 思路

利用位运算，原数每次循环右移1位，取末尾数字，然后新数加上这个末尾再循环左移。

#### 代码



```cpp
 public int reverseBits(int n) {
        int t = 0;
        for(int i = 0;i<32;i++) 
            t+= (1&(n>>i))<<(31-i);
        return t;
    }
```

运行时间2ms。

## 位1的个数

### 题目大意

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。
**示例1**：

> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

**示例2**：

> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

### 思路一：位运算

利用循环右移操作，每次移动1位，并且取出末尾与1做&操作，若不为1，说明末尾是0。



```cpp
public int hammingWeight(int n) {
         int cnt = 0;
        for(int i=0;i<32;i++)
        {
            cnt += n&1;
            n >>=1;
        }
        return cnt;
    }
```

### 思路二：n与n-1做位运算

当n与n-1做&运算，会把最后一个1的位变成0。





![img](https:////upload-images.jianshu.io/upload_images/18544309-036639b268a9ae5d.png?imageMogr2/auto-orient/strip|imageView2/2/w/879)



```cpp
 public int hammingWeight(int n) {
        int cnt = 0;
        while(n!=0) {
           ++cnt;
           n = n&(n-1);
        }
        return cnt;
    }
```

运行时间2 ms。

## 231 2的幂

### 题目大意

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
**示例1**：

> 输入: 1
> 输出: true
> 解释: 2^0 = 1

**示例2**：

> 输入: 16
> 输出: true
> 解释: 24 = 16

### 方法一：暴力法

采用迭代的方法，一个一个试。此题会超时。



```java
public boolean isPowerOfTwo(int n) {
        if(n==1) return true;
        int cur = 1;
        while(cur<n) {
            cur *=2;
            if(cur==n) return true;
        }
        return false;
    }
```

### 方法二：二分查找

采用打表和二分查找的方法，将int范围内的所有2^n全部存入一个整数表中，然后对整数表进行二分查找。



```java
int[] res = new int[31];
private void form() {
        res[0] = 1;
        for(int i=1;i<31;i++)
            res[i]=res[i-1]*2;
    }
public boolean isPowerOfTwo(int n) {
        form();
        if(n!=1 && n%2==1) return false;
        int low = 0;
        int high = 30;
        while(low<high) {
            int mid = (low+high)>>1;
            if(res[mid]==n) return true;
            else if(res[mid] > n)
                high = mid -1;
            else if(res[mid] < n)
                low = mid+1;
        }
        return res[low]==n?true:false;
    } 
```

运行时间3 ms,87.42%。

### 方法三：位运算

将2^n 和 2^n-1做与运算，结果一定为0。



```java
 public boolean isPowerOfTwo(int n) {
        if(n<=0) return false;
        return (n&(n-1))==0?true:false;
    }
```

运行时间2ms, 98.23%。

## 两整数之和

### 题目大意

不使用运算符 + 和 - ，计算两整数 a 、b 之和。
**示例1**：

> 输入: a = 1, b = 2
> 输出: 3

> 输入: a = -2, b = 3
> 输出: 1

### 思路

不用运算符，考虑位运算。a^b 得到不考虑进位的a+b结果；a&b<<1得到a+b的进位。





![img](https:////upload-images.jianshu.io/upload_images/18544309-6f04fb92ae5917bf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

image.png



```cpp
public int getSum(int a, int b) {
        while(b!=0) {
            int carry = (a&b)<<1;
            a = a^b;
            b = carry;
        }
        return a;
    }
```

## 405 数字转化为十六进制

### 题目大意

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用补码运算。
**注意**：

> 十六进制中所有字母(a-f)都必须是小写。
> 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。
> 给定的数确保在32位有符号整数范围内。
> 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

**示例1**：

> 输入:
> 26

输出:
"1a"

**示例2**：

> 输入:
> -1

输出:
"ffffffff"

#### 方法：位运算



```dart
public String toHex(int num) {
        if(num==0) return "0";
        char[] dict = {'0','1','2','3','4','5','6','7','8','9',
            'a','b','c','d','e','f'};
        StringBuffer sb = new StringBuffer();
        while(num!=0) {
            sb.append(dict[num&0xf]);
            num = num >>> 4;
        }
        return sb.reverse().toString();
    }
```

&0xf: 取末尾四位。
运行时间1 ms,击败88.12%。

### 2进制和10进制转化的java代码

 

```
private static String binaryToDecimal(int n) {
    StringBuilder str = new StringBuilder();
    while (n != 0) {
      str.insert(0, n % 2);
      n = n / 2;
    }
    return str.toString();
}
```

 

### 指定位置的位运算

 

1. x&(~0<<n) x最右边的n位清零
2. (x>>n)&1 得到x的第n位值(0或1)
3. x&(1<<n) 得到x的第n位幂值
4. x|(1<<n) 仅仅将第n位置1
5. x&(~(1<<n)) 仅仅将第n位置为0
6. x&((1<<n)-1) 将x最高位至第n位(包含第n位)清零

 

### tips

 

- 快速判断奇偶 x&1==1 奇数 x&1==0 偶数
- x>>1=x * 2的-1次方
- x<<1=x * 2的1次方
- x&-x 代表除最后一位1保留，其它位全部为0
- x&(x-1) 代表将最后一位1变成0
- x&~x =0
- x ^ 0=x
- x ^ 1...1=~x
- x ^ ~x =1....1
- x ^ x=0

 

## 布隆过滤器

 

### 应用场景

 

#### Redis缓存穿透

 

黑客发起的恶意攻击或是人为向缓存数据发起了一个缓存和db都不存在的数据查询请求。这个不存在的数据每次请求发现缓存中没有就会去DB查询，这样就失去了缓存存在意义。请求流量大时，可导致DB挂机不可用

 

#### 解决方案

 

在缓存之前，设置布隆过滤器，实际上是一个bitMap结构。当一个元素被加入时，将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，只要看看这些点是不是都是1就（大约）知道集合中有没有它了。如果这些点有任何一个0，则被检元素一定不存在；如果都是1，则被检元素很可能存在。不存在就直接返回（针对黑客攻击都采用这一方案）

 

### 资料

 

布隆过滤器的原理和实现 https://www.cnblogs.com/cpselvis/p/6265825.html

使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重 https://blog.csdn.net/tianyaleixiaowu/article/details/74721877

 

## LRU Cache

 

LRU全称是Least Recently Used，即最近最久未使用。LRU算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。是缓存中一种常见的机制

 

### 应用场景

 

Redis的key淘汰策略 缓存可以帮助快速存取数据，但是容量小，LRU思想来自“最近用到的数据被重用的概率比最早用到的数据大的多”，是一种十分高效的key淘汰策略

 

当缓存空间满了的时候，将最近最少使用的数据从缓存空间中删除以增加可用的缓存空间来缓存新内容。是一个淘汰策略。

 

内部有一个缓存列表。每当一个缓存数据被访问的时候，这个数据就会被提到列表头部，每次都这样的话，列表的尾部数据就是最近最不常使用的了，当缓存空间不足时，就会删除列表尾部的缓存数据。

 

## 排序

###  比较排序

- 选择排序 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
- 插入排序 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- 冒泡排序 每次冒出最大的元素。
- 归并排序 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。
- 快速排序 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

 

### 非比较排序

- 基数排序
- 计数排序
- 桶排序

十大经典排序算法(动图展示) https://www.cnblogs.com/onepixel/p/7674659.html

9 种经典排序算法可视化动画 https://www.bilibili.com/video/av25136272 

6 分钟看完 15 种排序算法动画展示 https://www.bilibili.com/video/av63851336